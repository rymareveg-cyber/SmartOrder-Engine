# Директива: Омниканальный приём заказов

## Цель
Создать единую систему приёма заказов из разных каналов (Telegram, Яндекс.Почта, Яндекс.Формы) с централизованной обработкой через Redis Queue.

## Входные данные
- **Telegram**: текстовые сообщения от пользователей, команды бота, callback_query от inline клавиатур
- **Яндекс.Почта**: входящие письма через IMAP
- **Яндекс.Формы**: JSON payload через webhook

## Выходные данные
Все сообщения из разных каналов преобразуются в единый формат и отправляются в Redis Queue (`orders:queue`) для дальнейшей обработки AI-парсером.

## Формат сообщения в очереди

### Telegram
```json
{
  "channel": "telegram",
  "user_id": "123456789",
  "chat_id": "123456789",
  "message": "Хочу 2 варочные панели по 120 тысяч",
  "timestamp": "2026-02-13T10:30:00Z",
  "message_id": 12345,
  "username": "username" (optional)
}
```

### Яндекс.Почта
```json
{
  "channel": "yandex_mail",
  "email": "sender@example.com",
  "subject": "Заказ товаров",
  "body": "Текст письма с заказом...",
  "attachments": [
    {
      "filename": "order.xlsx",
      "content": "base64_encoded_content"
    }
  ],
  "timestamp": "2026-02-13T10:30:00Z"
}
```

### Яндекс.Формы
```json
{
  "channel": "yandex_forms",
  "form_id": "form_123",
  "form_name": "Заказ товаров",
  "submission_id": "sub_456",
  "data": {
    "name": "Иван Иванов",
    "phone": "+79001234567",
    "products": "2 варочные панели"
  },
  "timestamp": "2026-02-13T10:30:00Z"
}
```

## Инструменты выполнения

### 1. Telegram Bot (`execution/telegram_bot.py`)
**Назначение**: Приём заказов через Telegram бота

**Функционал**:
- Обработка текстовых сообщений
- Команды: `/start`, `/help`, `/status`
- Inline клавиатуры для подтверждения заказов
- Отправка сообщений в Redis Queue
- Обработка ошибок с retry логикой

**Переменные окружения**:
- `TELEGRAM_BOT_TOKEN` - токен бота от @BotFather
- `REDIS_URL` - строка подключения к Redis
- `TELEGRAM_ADMIN_ID` - ID администратора для уведомлений

**Запуск**:
```bash
python execution/telegram_bot.py
```

### 2. Яндекс.Почта IMAP Parser (`execution/yandex_mail_parser.py`)
**Назначение**: Мониторинг и парсинг входящих писем

**Функционал**:
- Подключение к IMAP серверу Яндекс.Почты
- Polling каждые 2 минуты
- Фильтрация писем (по теме/отправителю)
- Парсинг текста и вложений
- Отправка в Redis Queue

**Переменные окружения**:
- `YANDEX_MAIL_IMAP_HOST=imap.yandex.ru`
- `YANDEX_MAIL_EMAIL` - email для мониторинга
- `YANDEX_MAIL_PASSWORD` - пароль или app password
- `YANDEX_MAIL_FOLDER=INBOX`
- `REDIS_URL`

**Запуск**:
```bash
python execution/yandex_mail_parser.py
```

### 3. Яндекс.Формы Webhook (`execution/yandex_forms_webhook.py`)
**Назначение**: Приём данных от Яндекс.Форм

**Функционал**:
- FastAPI endpoint `POST /webhook/yandex-forms`
- Валидация JSON payload
- Трансформация в единый формат
- Отправка в Redis Queue

**Переменные окружения**:
- `YANDEX_FORMS_SECRET` - секретный ключ для проверки подписи (опционально)
- `REDIS_URL`

**Запуск**:
```bash
python execution/yandex_forms_webhook.py
```

### 4. Queue Processor (`execution/queue_processor.py`)
**Назначение**: Обработка сообщений из Redis Queue

**Функционал**:
- Бесконечный цикл обработки (worker)
- BRPOP из Redis (блокирующий pop)
- Маршрутизация по каналам
- Вызов AI Parser для каждого сообщения
- Dead letter queue для ошибок

**Переменные окружения**:
- `REDIS_URL`
- `AI_PARSER_URL` - URL AI-парсера (для будущего этапа)
- `WORKER_CONCURRENCY=5` - количество параллельных воркеров

**Запуск**:
```bash
python execution/queue_processor.py
```

## Redis Queue структура

**Ключ**: `orders:queue`  
**Тип**: List (LPUSH для добавления, BRPOP для получения)  
**Формат**: JSON строки

**Операции**:
- `LPUSH orders:queue <json_message>` - добавление сообщения
- `BRPOP orders:queue 5` - получение сообщения (блокирующий, таймаут 5 сек)

**Dead Letter Queue**:
- Ключ: `orders:dead_letter`
- Сообщения, которые не удалось обработать после N попыток

## Обработка ошибок

### Telegram Bot
- **Ошибка Redis**: Retry с экспоненциальной задержкой (1s, 2s, 4s, max 30s)
- **Ошибка Telegram API**: Логирование и уведомление администратора
- **Критическая ошибка**: Отправка сообщения администратору через Telegram

### Яндекс.Почта
- **Ошибка IMAP подключения**: Автоматический reconnect с задержкой
- **Ошибка парсинга письма**: Логирование и пропуск письма (не блокирует очередь)
- **Ошибка Redis**: Retry логика

### Яндекс.Формы Webhook
- **Невалидный JSON**: Возврат 400 Bad Request
- **Ошибка Redis**: Логирование и возврат 500 Internal Server Error
- **Rate limiting**: Ограничение запросов (100 req/min на IP)

## Логирование

Все компоненты должны логировать:
- Успешную отправку сообщений в очередь
- Ошибки с полным traceback
- Метрики: количество обработанных сообщений, ошибки

**Формат логов**: Структурированное логирование (JSON) в файл `logs/omnichannel.log`

## Крайние случаи

### Telegram
- **Пустое сообщение**: Игнорировать
- **Команда без контекста**: Отправить help
- **Callback от устаревшего сообщения**: Игнорировать с уведомлением

### Яндекс.Почта
- **Пустое письмо**: Пропустить
- **Спам**: Фильтрация по отправителю (whitelist)
- **Большие вложения (>10MB)**: Пропустить вложение, обработать только текст

### Яндекс.Формы
- **Дубликат submission_id**: Игнорировать (idempotency)
- **Неожиданный формат данных**: Логировать и отправлять в очередь с флагом `needs_review`

## Тестирование

### Telegram Bot
1. Отправить текстовое сообщение → проверить в Redis Queue
2. Вызвать команду `/start` → проверить ответ
3. Нажать inline кнопку → проверить callback обработку

### Яндекс.Почта
1. Отправить тестовое письмо → проверить обработку через 2 минуты
2. Проверить парсинг вложений
3. Проверить фильтрацию спама

### Яндекс.Формы
1. Отправить тестовый webhook → проверить ответ 200 OK
2. Проверить валидацию данных
3. Проверить обработку дубликатов

## Критерии готовности

- ✅ Telegram бот принимает сообщения и отправляет в очередь
- ✅ IMAP парсер мониторит почту и обрабатывает письма
- ✅ Webhook принимает данные от Яндекс.Форм
- ✅ Все каналы отправляют данные в единую Redis Queue
- ✅ Queue Processor обрабатывает сообщения из очереди
- ✅ Обработка ошибок работает корректно
- ✅ Логирование всех событий

## Следующие шаги

После реализации всех каналов перейти к Этапу 3: AI-парсинг GPT для обработки сообщений из очереди.
